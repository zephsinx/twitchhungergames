<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Hunger Games Simulator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
  <script src="themes.js"></script>
  <script src="theme-config.js"></script>
  <style>
    * {
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: grayscale;
      font-smooth: never;
      text-rendering: optimizeSpeed;
    }

    html {
      font-size: 18px;
    }

    body {
      background: #121212;
      color: #fff;
      font-family: var(--theme-font-primary, sans-serif);
      margin: 0;
    }

    #header {
      display: flex;
      align-items: center;
      padding: 1em;
    }

    #header input,
    #header button,
    #header select {
      background: #333;
      border: none;
      color: #fff;
      padding: .7em 1em;
      border-radius: 4px;
      margin-right: .5em;
      font-family: var(--theme-font-primary, sans-serif);
      font-size: 1rem;
      transition: background .2s, filter .2s;
    }

    #header button:hover,
    #header select:hover,
    #proceedButton:hover,
    .startNewButton:hover,
    .removeBtn:hover {
      background: #444;
      filter: brightness(1.2);
      cursor: pointer;
    }

    #leaderboardButton {
      margin-left: auto;
    }

    #status {
      font-weight: bold;
      margin-right: 1em;
      font-size: 1rem;
    }

    #joinPrompt {
      text-align: center;
      font-size: 8em;
      margin: .2em 0;
      font-family: var(--theme-font-decorative, cursive);
    }

    #dayDisplay {
      text-align: center;
      font-size: 3.5em;
      margin: 0;
      font-family: var(--theme-font-decorative, cursive);
    }

    #phaseDesc {
      text-align: center;
      font-size: 1rem;
      margin: .5em 0;
    }

    #playersGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill,100px);
      gap: 1em;
      padding: 1em;
      justify-content: center;
      justify-items: center;
    }

    .player {
      position: relative;
      width: 80px;
    }

    .player img {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 8px;
    }

    .player .name {
      text-align: center;
      margin-top: .5em;
      word-break: break-word;
      font-size: 1rem;
    }

    .removeBtn {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(0,0,0,0.6);
      color: #f55;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 20px;
      text-align: center;
      transition: background .2s, filter .2s;
    }

    #eventLog {
      padding: 1.5em;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .event {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1em;
    }

    .avatars {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: .5em;
      margin: .5em 0;
    }

    .avatarWrap {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
    }

    .avatarWrap img {
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 4px;
    }

    .avatarWrap img.dead {
      filter: grayscale(100%);
    }

    .text {
      text-align: center;
      white-space: pre-wrap;
      font-family: var(--theme-font-primary, sans-serif);
      font-size: 1rem;
      margin: .5em 0;
    }

    #proceedContainer {
      text-align: center;
      margin: 1em;
      display: none;
    }

    #proceedButton {
      background: #333;
      border: none;
      color: #fff;
      padding: .7em 1em;
      border-radius: 4px;
      font-family: var(--theme-font-primary, sans-serif);
      font-size: 1rem;
    }

    #winnerScreen {
      display: none;
      text-align: center;
      padding: 2em;
    }

    #winnerAvatar {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      object-fit: cover;
    }

    #winnerText {
      font-size: 3.5em;
      margin: 1em 0;
      font-family: var(--theme-font-decorative, cursive);
    }

    #placementsGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill,120px);
      gap: 1.5em;
      justify-content: center;
      margin-top: 1em;
    }

    .placement {
      text-align: center;
      transition: opacity .3s;
      width: 120px;
    }

    .placement.dead img {
      filter: grayscale(100%);
      opacity: .5;
    }

    .placement img {
      width: 100px;
      height: 100px;
      object-fit: cover;
      border-radius: 8px;
    }

    .placement .rank {
      font-size: 1.2em;
      margin-top: .7em;
      font-family: var(--theme-font-primary, sans-serif);
    }

    .placement .name,
    .placement .kills {
      font-size: 1rem;
      font-family: var(--theme-font-primary, sans-serif);
      word-break: break-word;
      white-space: normal;
    }

    .startNewButton {
      margin: .5em;
      padding: .7em 1.2em;
      background: #333;
      border: none;
      color: #fff;
      border-radius: 4px;
      font-family: var(--theme-font-primary, sans-serif);
      font-size: 1rem;
    }

    #deathLogContainer {
      margin: 2em 0;
      width: 100%;
      padding: 0 1em;
    }

    #deathLogContainer h3 {
      font-size: 1.2rem;
      margin-bottom: .5em;
      font-family: var(--theme-font-primary, sans-serif);
      text-align: left;
    }

    #deathLog {
      width: 100%;
      height: 300px;
      background: #222;
      border: 1px solid #555;
      border-radius: 4px;
      padding: .5em;
      font-family: var(--theme-font-primary, monospace);
      font-size: 1rem;
      overflow-y: scroll;
      text-align: left;
      white-space: pre-wrap;
    }

    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip-box {
      visibility: hidden;
      position: absolute;
      z-index: 100;
      top: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(4px);
      background: #222;
      color: #fff;
      border: 1px solid #555;
      padding: .5em;
      border-radius: 4px;
      white-space: pre;
      font-family: var(--theme-font-primary, sans-serif);
      font-size: .9rem;
      text-align: left;
      width: max-content;
      max-width: none;
    }

    .tooltip-container:hover .tooltip-box {
      visibility: visible;
    }

    /* Leaderboard overlay */
    #leaderboardOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #leaderboardOverlay .overlayContent {
      position: relative;
      background: #222;
      padding: 2em;
      border-radius: 8px;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
      text-align: left;
    }

    #leaderboardOverlay h2 {
      margin-top: 0;
      font-family:var(--theme-font-decorative, cursive);
    }

    #closeOverlay {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
      transition: color .2s;
    }

    #closeOverlay:hover {
      color: #f55;
    }

    #leaderboardTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }

    #leaderboardTable th,
    #leaderboardTable td {
      padding: .5em;
      border-bottom: 1px solid #444;
    }

    #leaderboardTable th {
      text-align: left;
      cursor: pointer;
      user-select: none;
    }

    #leaderboardTable th.sort-asc::after {
      content: " ▲";
    }

    #leaderboardTable th.sort-desc::after {
      content: " ▼";
    }
  </style>
</head>

<body>
  <div id="header">
    <input id="channelInput" placeholder="Enter Twitch channel">
    <button id="connectButton">Connect</button>
    <span id="status"></span>
    <button id="startButton" disabled>Start Games</button>
    <button id="debugButton">Add Fake Players</button>
    <button id="leaderboardButton">Leaderboard</button>
    <select id="themeSelector" style="margin-left: auto; margin-right: 0.5em;">
      <option value="noita">Noita</option>
      <option value="fridge">Fridge Survival</option>
    </select>
  </div>

  <div id="joinPrompt">!play to join</div>
  <div id="dayDisplay"></div>
  <div id="phaseDesc"></div>
  <div id="playersGrid"></div>
  <div id="eventLog"></div>

  <div id="proceedContainer">
    <button id="proceedButton">Proceed to Next Phase</button>
  </div>

  <div id="winnerScreen">
    <img id="winnerAvatar" src="">
    <div id="winnerText"></div>
    <hr style="width:50%;border-color:#555;margin:2em auto">
    <div id="placementsGrid"></div>
    <div id="deathLogContainer">
      <h3 id="deathEventsHeader">Death Events:</h3>
      <div id="deathLog"></div>
    </div>
    <button class="startNewButton" id="newGameSameButton">Start new game (same players)</button>
    <button class="startNewButton" id="newGameAllButton">Start new game</button>
  </div>

  <div id="leaderboardOverlay">
    <div class="overlayContent">
      <button id="closeOverlay">×</button>
      <h2>Leaderboard</h2>
      <table id="leaderboardTable">
        <thead>
          <tr>
            <th data-key="username">Name</th>
            <th data-key="wins">Wins</th>
            <th data-key="kills">Kills</th>
            <th data-key="deaths">Deaths</th>
            <th data-key="maxDays">Max Days</th>
            <th data-key="totalDays">Total Days</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tmi.js@latest/dist/tmi.min.js"></script>
  <script>
    // escape helper
    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

    // Security utility functions
    function escapeHtml(text) {
      if (typeof text !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function validateColor(color) {
      if (!color || typeof color !== 'string') return '#fff';
      // Remove whitespace
      color = color.trim();
      // Check for hex format (#RRGGBB or #RGB)
      if (/^#[0-9A-Fa-f]{3}$/.test(color) || /^#[0-9A-Fa-f]{6}$/.test(color)) {
        return color;
      }
      // Check for rgb() or rgba() format
      const rgbMatch = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)$/);
      if (rgbMatch) {
        const r = Math.max(0, Math.min(255, parseInt(rgbMatch[1])));
        const g = Math.max(0, Math.min(255, parseInt(rgbMatch[2])));
        const b = Math.max(0, Math.min(255, parseInt(rgbMatch[3])));
        return `rgb(${r}, ${g}, ${b})`;
      }
      // Invalid color, return default
      return '#fff';
    }

    // Initialize theme on page load
    if (typeof window.applyTheme !== 'undefined' && typeof window.themeConfig !== 'undefined') {
      window.applyTheme(window.themeConfig);
      const deathEventsHeaderEl = document.getElementById('deathEventsHeader');
      if (deathEventsHeaderEl && window.themeConfig.messages.deathEventsHeader) {
        deathEventsHeaderEl.textContent = window.themeConfig.messages.deathEventsHeader;
      }
    }

    const RENDER_DELAY      = 10;
    const fakeAvatars       = ['images/pfp1.png','images/pfp2.png','images/pfp3.png','images/pfp4.png','images/pfp5.png','images/pfp6.png'];
    const adjectives        = ['Iron','Silver','Golden','Dusky','Silent','Swift','Fierce','Mystic','Crimson','Shadow'];
    const nouns             = ['Wolf','Raven','Phoenix','Dragon','Saber','Viper','Falcon','Stalker','Hunter','Wraith'];
    function randomName(){
      return adjectives[Math.floor(Math.random()*adjectives.length)] +
             nouns[Math.floor(Math.random()*nouns.length)] +
             Math.floor(Math.random()*1000);
    }
    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    // global stats
    const STORAGE_PREFIX = (window.themeConfig && window.themeConfig.storagePrefix) || 'game';

    let globalStats  = JSON.parse(localStorage.getItem(`${STORAGE_PREFIX}GlobalStats`)  || '{}');
    let globalColors = JSON.parse(localStorage.getItem(`${STORAGE_PREFIX}GlobalColors`) || '{}');
    function saveGlobalStats(){ localStorage.setItem(`${STORAGE_PREFIX}GlobalStats`, JSON.stringify(globalStats)); }
    function saveGlobalColors(){ localStorage.setItem(`${STORAGE_PREFIX}GlobalColors`, JSON.stringify(globalColors)); }
    function initGlobal(u){
      if(!globalStats[u]) globalStats[u]={wins:0,kills:0,deaths:0,totalDays:0,maxDays:0};
    }

    function getUserTooltipText(u, runKills, runDays){
      initGlobal(u);
      const g = globalStats[u];
      return `Run Stats:\nKills: ${runKills}\nDays Survived: ${runDays}\n---\nGlobal Stats:\nWins: ${g.wins}\nKills: ${g.kills}\nDeaths: ${g.deaths}\nMax Days: ${g.maxDays}\nTotal Days: ${g.totalDays}`;
    }

    let client,
        players            = new Set(),
        participants       = [],
        eventsData,
        itemsData,
		materialsData,
        eliminationOrder   = [],
        killedThisDay      = [],
        deathEventsLog     = [],
        currentDay         = 1,
        stage              = 0,
        daysSinceEvent     = 0,
        consecutiveNoDeaths= 0,
        gameStarted        = false,
        currentPhaseType   = null,
        leaderboardSort    = { key:null, asc:true };

    // Make gameStarted accessible globally for theme switching
    window.gameStarted = false;

    // DOM refs
    const chInput        = document.getElementById('channelInput');
    const btnConnect     = document.getElementById('connectButton');
    const status         = document.getElementById('status');
    const btnStart       = document.getElementById('startButton');
    const btnDebug       = document.getElementById('debugButton');
    const btnLeaderboard = document.getElementById('leaderboardButton');
    const joinPrompt     = document.getElementById('joinPrompt');
    const procCont       = document.getElementById('proceedContainer');
    const btnProc        = document.getElementById('proceedButton');
    const dayDisplay     = document.getElementById('dayDisplay');
    const phaseDesc      = document.getElementById('phaseDesc');
    const playersGrid    = document.getElementById('playersGrid');
    const eventLog       = document.getElementById('eventLog');
    const winnerScreen   = document.getElementById('winnerScreen');
    const winnerAvatar   = document.getElementById('winnerAvatar');
    const winnerText     = document.getElementById('winnerText');
    const placementsGrid = document.getElementById('placementsGrid');
    const deathLogEl     = document.getElementById('deathLog');
    const deathEventsHeader = document.getElementById('deathEventsHeader');
    const btnNewSame     = document.getElementById('newGameSameButton');
    const btnNewAll      = document.getElementById('newGameAllButton');
    const overlay        = document.getElementById('leaderboardOverlay');
    const closeOverlay   = document.getElementById('closeOverlay');
    const lbTableBody    = document.querySelector('#leaderboardTable tbody');
    const lbHeaders      = document.querySelectorAll('#leaderboardTable th');

    let eventHandlersLoaded = false;

    const script = document.createElement('script');
    script.src = 'event-handlers.js';
    script.onload = () => {
      if (typeof window.eventHandlers !== 'undefined') {
        eventHandlersLoaded = true;
      }
    };
    script.onerror = (err) => console.error('Failed to load event handlers:', err);
    document.head.appendChild(script);

    let polymorphedPlayers = new Map();

    function getDisplayName(username) {
      if (eventHandlersLoaded && window.eventHandlers && window.eventHandlers.polymorph && polymorphedPlayers.has(username)) {
        return window.eventHandlers.polymorph.getDisplayName(username, { polymorphedPlayers });
      }
      return username;
    }

    function loadGameData(themeName) {
      btnStart.disabled = true;
      if (status) {
        status.textContent = "Loading data...";
        status.style.color = "#ffa500";
      }

      if (typeof window.loadThemeData === "undefined") {
        console.error("loadThemeData function not available");
        if (status) {
          status.textContent = "Error: Theme system not loaded";
          status.style.color = "#f00";
        }
        return Promise.reject(new Error("Theme system not loaded"));
      }

      return window
        .loadThemeData(themeName)
        .then(({ eventsData: e, itemsData: w, materialsData: m }) => {
          eventsData = e;
          itemsData = w;
          materialsData = m;
          btnStart.disabled = false;
          if (status) {
            status.textContent = "";
            status.style.color = "";
          }
        })
        .catch((err) => {
          console.error("Failed to load game data:", err);
          btnStart.disabled = true;
          if (status) {
            status.textContent = `Error: ${err.message}`;
            status.style.color = "#f00";
          }
          throw err;
        });
    }

    function initializeData() {
      const saved = localStorage.getItem('twitchChannel');
      if (saved) { chInput.value = saved; connect(saved); }

      const currentTheme = localStorage.getItem('selectedTheme') || (typeof defaultTheme !== 'undefined' ? defaultTheme : 'noita');
      loadGameData(currentTheme).catch(err => {
        console.error("Initial data load failed:", err);
      });
    }

    if (document.readyState === 'loading') {
      window.addEventListener('load', initializeData);
    } else {
      initializeData();
    }

    btnConnect.addEventListener('click', ()=>{
      const ch=chInput.value.trim().toLowerCase();
      if(!ch) return;
      localStorage.setItem('twitchChannel',ch);
      connect(ch);
    });

    // Theme selector
    const themeSelector = document.getElementById('themeSelector');
    if (themeSelector) {
      if (typeof window.getAvailableThemes === 'function') {
        const availableThemes = window.getAvailableThemes();
        if (availableThemes.length > 0 && availableThemes.length !== themeSelector.options.length) {
          themeSelector.innerHTML = '';
          availableThemes.forEach(themeKey => {
            const option = document.createElement('option');
            option.value = themeKey;
            try {
              const config = window.loadTheme ? window.loadTheme(themeKey) : null;
              option.textContent = config && config.title ?
                config.title.replace(' Simulator', '').replace(' Hunger Games', '') :
                themeKey.charAt(0).toUpperCase() + themeKey.slice(1);
            } catch (e) {
              option.textContent = themeKey.charAt(0).toUpperCase() + themeKey.slice(1);
            }
            themeSelector.appendChild(option);
          });
        }
      }
      // Load saved theme preference
      let currentTheme = localStorage.getItem('selectedTheme') || (typeof defaultTheme !== 'undefined' ? defaultTheme : 'noita');
      if (themeSelector.querySelector(`option[value="${currentTheme}"]`)) {
        themeSelector.value = currentTheme;
      }

      themeSelector.addEventListener('change', async (e) => {
        const newTheme = e.target.value;
        const previousTheme = currentTheme;
        if (window.switchTheme) {
          const switched = await window.switchTheme(newTheme);
          if (!switched) {
            themeSelector.value = previousTheme;
            alert('Cannot change theme during an active game.');
          } else {
            try {
              await loadGameData(newTheme);
              currentTheme = newTheme;
              // Update theme-specific UI elements
              if (deathEventsHeader && window.themeConfig && window.themeConfig.messages.deathEventsHeader) {
                deathEventsHeader.textContent = window.themeConfig.messages.deathEventsHeader;
              }
            } catch (err) {
              themeSelector.value = previousTheme;
              if (window.switchTheme) {
                await window.switchTheme(previousTheme);
              }
              alert(`Failed to load theme data: ${err.message}`);
            }
          }
        }
      });
    }

    function connect(ch){
      if(client) client.disconnect();
      players.clear();
      playersGrid.innerHTML='';
      status.textContent='';
      gameStarted=false;
      joinPrompt.style.display='block';

      client=new tmi.Client({channels:[ch]});
      client.connect()
        .then(()=>{status.textContent='Connected';status.style.color='#0f0';})
        .catch(()=>{status.textContent='Error';status.style.color='#f00';});

      client.on('message',(_,tags,msg)=>{
        if(gameStarted) return;
        if(msg.trim().toLowerCase()==='!play'){
          const u=tags.username;
          if(!players.has(u)){
            players.add(u);
            addPlayer(u,tags.color);
            btnStart.disabled = players.size===0;
          }
        }
      });
    }

    btnStart.addEventListener('click', ()=>{
      if(players.size<1){ alert(window.themeConfig.messages.minPlayersRequired); return; }
      gameStarted=true;
      window.gameStarted = true;
      joinPrompt.style.display='none';
      participants=Array.from(players).map(u=>{
        const el=document.querySelector(`[data-username="${u}"]`);
        return {
          username:u,
          color:globalColors[u]||el.querySelector('.name').style.color||'#fff',
          avatar:el.querySelector('img').src,
          alive:true,
          kills:0
        };
      });
      eliminationOrder=[];
      currentDay=1; stage=0; daysSinceEvent=0; consecutiveNoDeaths=0;
      killedThisDay=[]; deathEventsLog=[]; currentPhaseType=null;
      playersGrid.style.display='none';
      btnStart.style.display='none';
      btnDebug.style.display='none';
      procCont.style.display='block';
      nextPhase();
    });

    btnDebug.addEventListener('click', ()=>{
      for(let i=0;i<50;i++){
        let u;
        do{u=randomName();}while(players.has(u));
        players.add(u);
        addFakePlayer(u,'#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0'));
        btnStart.disabled=false;
      }
    });

    btnProc.addEventListener('click',()=>nextPhase());
    btnLeaderboard.addEventListener('click',showLeaderboard);
    closeOverlay.addEventListener('click',()=>overlay.style.display='none');
    btnNewSame.addEventListener('click',()=>backToJoin(true));
    btnNewAll.addEventListener('click',()=>backToJoin(false));

    lbHeaders.forEach(th=>{
      th.addEventListener('click',()=>{
        const key=th.dataset.key;
        if(leaderboardSort.key===key){
          leaderboardSort.asc=!leaderboardSort.asc;
        } else {
          leaderboardSort.key=key;
          leaderboardSort.asc=(key==='username');
        }
        lbHeaders.forEach(h=>h.classList.remove('sort-asc','sort-desc'));
        th.classList.add(leaderboardSort.asc?'sort-asc':'sort-desc');
        renderLeaderboard();
      });
    });

    function backToJoin(samePlayers){
      winnerScreen.style.display='none';
      procCont.style.display='none';
      eventLog.innerHTML='';
      dayDisplay.textContent='';
      phaseDesc.textContent='';
      joinPrompt.style.display='block';
      playersGrid.style.display='grid';
      btnStart.style.display='inline-block';
      btnDebug.style.display='inline-block';
      btnStart.disabled = !samePlayers && players.size===0;

      if(!samePlayers){
        players.clear();
        playersGrid.innerHTML='';
      }
      gameStarted = false;
      window.gameStarted=false;
      participants=[];
      eliminationOrder=[];
      daysSinceEvent=0;
      consecutiveNoDeaths=0;
      killedThisDay=[];
      deathEventsLog=[];
      currentPhaseType=null;
      polymorphedPlayers.clear();
    }

    async function nextPhase(){
      if(participants.filter(p=>p.alive).length<=1){
        showWinner();
        return;
      }
      switch(stage){
        case 0: await runPhase('bloodbath'); stage=1; break;
        case 1: await runPhase('day');        stage=2; break;
        case 2:
          if(killedThisDay.length>0){
            showFallen(currentDay);
            stage=3;
          } else {
            stage=3;
            await nextPhase();
          }
          break;
        case 3: await runPhase('night'); currentDay++; stage=1; break;
      }
    }

    function showFallen(day){
      eventLog.innerHTML='';
      dayDisplay.textContent=formatMessage(window.themeConfig.messages.fallenPlayers, { day });
      dayDisplay.style.color='#aaa';
      phaseDesc.textContent='';
      const n=killedThisDay.length;
      const txt=document.createElement('div');
      txt.className='text';
      const deathSound = window.themeConfig.terminology.deathSound || 'signal';
      const pluralizedSound = n !== 1 ? deathSound + 's' : deathSound;
      txt.textContent = formatMessage(window.themeConfig.messages.deathSound, { count: n, sound: pluralizedSound });
      const grid=document.createElement('div');
      grid.className='avatars';
      killedThisDay.forEach(u=>{
        const p=participants.find(x=>x.username===u);
        const displayName = getDisplayName(u);
        const wrap=document.createElement('div'); wrap.className='avatarWrap';
        const img=document.createElement('img'); img.src=p.avatar; img.className='dead';
        const nmC=document.createElement('div'); nmC.className='tooltip-container text';
        const sp=document.createElement('span'); sp.textContent=displayName; sp.style.color=p.color;
        const tip=document.createElement('div'); tip.className='tooltip-box';
        tip.innerText=getUserTooltipText(u,p.kills,day);
        nmC.append(sp,tip);
        wrap.append(img,nmC);
        grid.appendChild(wrap);
      });
      eventLog.append(txt,grid);
      killedThisDay=[];
    }

    function getStepType(isDay){
      const fc=100*(daysSinceEvent**2/55)+(9/55);
      if(isDay && Math.random()*100<fc){ daysSinceEvent=0; return 'feast'; }
      if(daysSinceEvent>0 && Math.floor(Math.random()*20)===0){ daysSinceEvent=0; return 'arena'; }
      daysSinceEvent++;
      return isDay?'day':'night';
    }

    async function runPhase(type){
      eventLog.innerHTML='';
      let step=type;
      if(type==='day'||type==='night') {
        currentPhaseType=getStepType(type==='day');
        step=currentPhaseType;
      } else {
        currentPhaseType=type;
      }
      if(step==='feast'){
        const ev=eventsData.feast;
        phaseDesc.textContent=ev.description;
        dayDisplay.textContent=ev.title;
        dayDisplay.style.color=ev.color;
        await runEvents(ev);
      } else if(step==='arena'){
        const ev=eventsData.arena[Math.floor(Math.random()*eventsData.arena.length)];
        phaseDesc.textContent=ev.description;
        dayDisplay.textContent=ev.title;
        dayDisplay.style.color=ev.color;
        await runEvents(ev);
      } else {
        const ev=eventsData[step];
        phaseDesc.textContent=ev.description||'';
        const title=ev.title.replace('{0}', step==='bloodbath'?'':currentDay);
        dayDisplay.textContent=title;
        dayDisplay.style.color=step==='night'? '#88ccff':ev.color;
        await runEvents(ev);
      }
      consecutiveNoDeaths = killedThisDay.length===0 ? consecutiveNoDeaths+1:0;
    }

    async function runEvents(evObj){
      const aliveSet=new Set(participants.filter(p=>p.alive));
      const base=Math.floor(Math.random()*3)+1;
      const factor=base+consecutiveNoDeaths+(stage===0?1:0);
      const msgs=[];

      const genericEvents = eventsData.generic || { nonfatal: [], fatal: [] };
      const isArenaEvent = evObj.title && evObj.title.startsWith('Arena Event');
      const isFeastEvent = evObj.title && evObj.title === 'The Feast';
      const isBloodbathEvent = evObj.title && evObj.title === 'The Bloodbath';

      while(aliveSet.size>0){
        const roll=Math.floor(Math.random()*11);
        const useFatal = roll<factor && participants.filter(p=>p.alive).length>1;
        const phasePool = (useFatal ? evObj.fatal : evObj.nonfatal) || [];
        const genericPool = (useFatal ? genericEvents.fatal : genericEvents.nonfatal) || [];

        let pool;
        if (isArenaEvent || isFeastEvent || isBloodbathEvent) {
          const multiplier = (phasePool.length > 0 && genericPool.length > 0)
            ? Math.ceil((3 * genericPool.length) / phasePool.length)
            : 1;
          const weightedPhasePool = Array(multiplier).fill(null).flatMap(() => phasePool);
          pool = [...weightedPhasePool, ...genericPool];
        } else {
          pool = [...phasePool, ...genericPool];
        }
        pool = pool.filter(a=>a.tributes<=aliveSet.size);
        if(!pool.length) break;

        // Calculate total weight
        let totalWeight = 0;
        pool.forEach(action => {
          const weight = action.weight !== undefined ? action.weight : 1;
          if (weight <= 0) {
            action._effectiveWeight = 1;
          } else {
            action._effectiveWeight = weight;
          }
          totalWeight += action._effectiveWeight;
        });

        if (totalWeight <= 0) {
          console.error('All events have zero or negative weight');
          break;
        }

        // Weighted random selection using cumulative distribution
        const random = Math.random() * totalWeight;
        let cumulative = 0;
        let action = null;

        for (const candidate of pool) {
          cumulative += candidate._effectiveWeight;
          if (random <= cumulative) {
            action = candidate;
            break;
          }
        }

        if (!action) {
          action = pool[0];
        }

        pool.forEach(a => {
          if (a._effectiveWeight !== undefined) {
            delete a._effectiveWeight;
          }
        });
        const pick=[]; const avail=Array.from(aliveSet);
        for(let i=0;i<action.tributes;i++){
          const idx=Math.floor(Math.random()*avail.length);
          pick.push(avail.splice(idx,1)[0]);
          aliveSet.delete(pick[pick.length-1]);
        }

        let txt = action.msg;
        for(let i=0;i<pick.length;i++){
          const displayName = getDisplayName(pick[i].username);
          txt = txt.replace(new RegExp(`\\{${i}\\}`, 'g'), displayName);
        }

        const killsCount = Array.isArray(action.killed)? action.killed.length : 0;

        if (action.customHandler && eventHandlersLoaded && window.eventHandlers && window.eventHandlers[action.customHandler] && typeof window.eventHandlers[action.customHandler].execute === 'function') {
          window.eventHandlers[action.customHandler].execute({
            picks: pick,
            currentRound: currentDay
          }, { polymorphedPlayers });
        }
		const types = (window.themeConfig && window.themeConfig.itemCategories) ||
			Object.keys(itemsData).concat(Object.keys(materialsData));
		[...types, "weapon_any", "item_any", "material_any", "liquid_any", "sand_any", "food_any"].forEach(cat => {
		let placeholder = `{${cat}}`;
		let list;
		if (cat === "weapon_any") {
			list = types.flatMap(c => itemsData[c] || []).filter(w => w.max_kills >= killsCount);
		} else if (cat.startsWith("weapon_")) {
			list = (itemsData[cat] || []).filter(w => w.max_kills >= killsCount);
		} else if (cat === "material_any") {
			list = types.flatMap(c => materialsData[c] || []);
		} else if (cat === "liquid_any") {
			list = types
			.filter(c => c.startsWith("liquid_"))
			.flatMap(c => materialsData[c] || []);
		} else if (cat === "sand_any") {
			list = types
			.filter(c => c.startsWith("sand_"))
			.flatMap(c => materialsData[c] || []);
		}else if (cat === "food_any") {
			list = types
			.filter(c => c.startsWith("food_"))
			.flatMap(c => materialsData[c] || []);
		} else if (cat.startsWith("material_") || cat.startsWith("liquid_") || cat.startsWith("sand_") || cat.startsWith("food_") ) {
			list = (materialsData[cat] || []);
		} else if (cat === "item_any") {
			list = types.flatMap(c => itemsData[c] || []);
		} else {
			list = itemsData[cat] || [];
		}

		if (txt.includes(placeholder)) {
			const candidates = list;
			const pick = candidates[Math.floor(Math.random() * candidates.length)];
			const chosen = candidates.length
			? (pick.name !== undefined ? pick.name : pick)
			: placeholder;
			txt = txt.replace(new RegExp(escapeRegExp(placeholder), 'g'), chosen);
		}
		});

        msgs.push({
          picks: pick,
          text: txt,
          killed: action.killed||[],
          killer: action.killer||[],
          hidden: action.hidden===true
        });
      }

      for(const m of msgs){
        if(m.killed.length){
          // track kills/deaths
          m.killer.forEach(kr=>{
            const kp=m.picks[kr];
            kp.kills+=m.killed.length;
            initGlobal(kp.username);
            globalStats[kp.username].kills+=m.killed.length;
          });
          m.killed.forEach(idx=>{
            const v=m.picks[idx];
            if(v && v.alive){
              v.alive=false;
              v.deathDay=currentDay;
              killedThisDay.push(v.username);
              eliminationOrder.push(v.username);
              initGlobal(v.username);
              globalStats[v.username].deaths++;
            }
          });
          saveGlobalStats();
        }
        if(m.killed.length && !m.hidden){
          let rec=m.text;
          m.picks.forEach(p=>{
            const displayName = getDisplayName(p.username);
            const safeDisplayName = escapeHtml(displayName);
            const safeColor = validateColor(p.color);
            const col=`<span style="color:${safeColor}">${safeDisplayName}</span>`;
            rec=rec.split(displayName).join(col);
          });
          deathEventsLog.push(rec);
        }
        if(!m.hidden){
          const evEl=document.createElement('div'), avs=document.createElement('div');
          evEl.className='event';
          avs.className='avatars';
          m.picks.forEach(p=>{
            const wrap=document.createElement('div');
            wrap.className='avatarWrap';
            const img=document.createElement('img');
            img.src=p.avatar;
            wrap.append(img);
            avs.appendChild(wrap);
          });
          const txtEl=document.createElement('div');
          txtEl.className='text';
          // Build DOM structure safely instead of using innerHTML
          // Process text and replace displayNames with DOM elements
          let remainingText = m.text;
          const pickMap = new Map();
          m.picks.forEach(p=>{
            const displayName = getDisplayName(p.username);
            if (!pickMap.has(displayName)) {
              pickMap.set(displayName, []);
            }
            pickMap.get(displayName).push(p);
          });

          // Process text and replace displayNames with DOM elements
          // Sort names by length descending to handle longer names first (avoid partial matches)
          const sortedNames = Array.from(pickMap.keys()).sort((a, b) => b.length - a.length);
          let lastIndex = 0;
          const replacements = [];

          // Find all occurrences of each displayName
          for (const displayName of sortedNames) {
            const picks = pickMap.get(displayName);
            let searchIndex = 0;
            while (true) {
              const index = remainingText.indexOf(displayName, searchIndex);
              if (index === -1) break;
              replacements.push({
                index: index,
                length: displayName.length,
                displayName: displayName,
                pick: picks[0] // Use first pick if multiple have same displayName
              });
              searchIndex = index + 1;
            }
          }

          // Sort replacements by index, then by length descending (prefer longer matches)
          replacements.sort((a, b) => {
            if (a.index !== b.index) return a.index - b.index;
            return b.length - a.length; // Longer matches first at same index
          });

          // Remove overlapping replacements (keep longer ones)
          const nonOverlapping = [];
          let lastEnd = 0;
          replacements.forEach(repl => {
            if (repl.index >= lastEnd) {
              nonOverlapping.push(repl);
              lastEnd = repl.index + repl.length;
            }
          });

          // Build DOM structure
          let currentIndex = 0;
          nonOverlapping.forEach(repl => {
            // Add text before the match
            if (repl.index > currentIndex) {
              const textNode = document.createTextNode(remainingText.substring(currentIndex, repl.index));
              txtEl.appendChild(textNode);
            }

            // Add tooltip element for the displayName
            const p = repl.pick;
            const safeColor = validateColor(p.color);
            const tooltipContainer = document.createElement('span');
            tooltipContainer.className = 'tooltip-container';
            const nameSpan = document.createElement('span');
            nameSpan.style.color = safeColor;
            nameSpan.textContent = repl.displayName;
            const tooltipBox = document.createElement('div');
            tooltipBox.className = 'tooltip-box';
            tooltipBox.textContent = getUserTooltipText(p.username, p.kills, currentDay);
            tooltipContainer.appendChild(nameSpan);
            tooltipContainer.appendChild(tooltipBox);
            txtEl.appendChild(tooltipContainer);

            currentIndex = repl.index + repl.length;
          });

          // Add remaining text
          if (currentIndex < remainingText.length) {
            const textNode = document.createTextNode(remainingText.substring(currentIndex));
            txtEl.appendChild(textNode);
          }
          evEl.append(avs,txtEl);
          eventLog.appendChild(evEl);
          await sleep(RENDER_DELAY);
        }
      }
    }

    function showWinner(){
      procCont.style.display='none';
      eventLog.innerHTML='';
      dayDisplay.textContent='';
      phaseDesc.textContent='';

      participants.forEach(p=>{
        const days = p.deathDay||(currentDay-1);
        initGlobal(p.username);
        globalStats[p.username].totalDays += days;
        if(days>globalStats[p.username].maxDays) globalStats[p.username].maxDays=days;
        globalStats[p.username].wins  += p.alive?1:0;

        if(p.alive && eventHandlersLoaded && window.eventHandlers && window.eventHandlers.polymorph && polymorphedPlayers.has(p.username)) {
          const polymorph = polymorphedPlayers.get(p.username);
          if(polymorph && polymorph.newForm) {
            initGlobal(polymorph.newForm);
            globalStats[polymorph.newForm].wins += 1;
          }
        }
      });
      saveGlobalStats();

      const surv = participants.filter(p=>p.alive);
      let title='',avatar='';
      if(surv.length===1){
        if (eventHandlersLoaded && window.eventHandlers && window.eventHandlers.polymorph && polymorphedPlayers.has(surv[0].username)) {
          title = window.eventHandlers.polymorph.getWinnerMessage(surv[0].username, { polymorphedPlayers });
        } else {
          title = formatMessage(window.themeConfig.messages.winnerMessage, { username: surv[0].username });
        }
        avatar=surv[0].avatar;
      } else {
        title=window.themeConfig.messages.noSurvivors;
      }
      winnerAvatar.src=avatar;
      winnerText.textContent=title;
      placementsGrid.innerHTML='';

      const finalOrder=surv.length===1
        ? [surv[0].username,...eliminationOrder.slice().reverse()]
        : eliminationOrder.slice().reverse();

      finalOrder.forEach((u,i)=>{
        const p=participants.find(x=>x.username===u);
        if(!p) return;
        const displayName = getDisplayName(u);
        const wrap=document.createElement('div');
        wrap.className='placement'+(p.alive?'':' dead');
        const img=document.createElement('img'); img.src=p.avatar;
        const rank=document.createElement('div'); rank.className='rank';
        rank.textContent=`#${i+1}`;
        const nmC=document.createElement('div'); nmC.className='name tooltip-container';
        const sp=document.createElement('span'); sp.textContent=displayName; sp.style.color=p.color;
        const tip=document.createElement('div'); tip.className='tooltip-box';
        tip.innerText=getUserTooltipText(u,p.kills,p.deathDay||(currentDay-1));
        nmC.append(sp,tip);
        const kc=document.createElement('div');
        kc.className='kills';
        const killsLabel = (window.themeConfig && window.themeConfig.messages.killsLabel) || 'Kills:';
        kc.textContent=`${killsLabel} ${p.kills}`;
        wrap.append(img,rank,nmC,kc);
        placementsGrid.appendChild(wrap);
      });

      // Clear and rebuild death log using DOM methods for security
      deathLogEl.textContent = ''; // Clear existing content
      deathEventsLog.forEach((logEntry, index) => {
        if (index > 0) {
          // Add line break between entries
          deathLogEl.appendChild(document.createElement('br'));
        }
        // Create a container for this log entry
        // Since logEntry already contains HTML (with escaped user data), we need to parse it safely
        // Use a temporary div to parse the HTML, then move nodes
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = logEntry; // Safe because we escaped user data when building deathEventsLog
        // Move all child nodes to deathLogEl
        while (tempDiv.firstChild) {
          deathLogEl.appendChild(tempDiv.firstChild);
        }
      });
      winnerScreen.style.display='block';
    }

    function renderLeaderboard(){
      const list=Object.entries(globalStats);
      const key=leaderboardSort.key;
      if(key){
        list.sort((a,b)=>{
          const va=(key==='username'?a[0].localeCompare(b[0]):a[1][key]-b[1][key]);
          return leaderboardSort.asc?va:-va;
        });
      } else {
        list.sort((a,b)=>b[1].wins-a[1].wins||b[1].kills-a[1].kills);
      }
      lbTableBody.innerHTML='';
      list.forEach(([u,st])=>{
        const tr=document.createElement('tr');
        const tdName=document.createElement('td');
        tdName.textContent=u;
        tdName.style.color=globalColors[u]||'#fff';
        tr.appendChild(tdName);
        ['wins','kills','deaths','maxDays','totalDays'].forEach(k=>{
          const td=document.createElement('td');
          td.textContent=st[k];
          tr.appendChild(td);
        });
        lbTableBody.appendChild(tr);
      });
      overlay.style.display='flex';
    }

    function showLeaderboard(){
      lbHeaders.forEach(h=>h.classList.remove('sort-asc','sort-desc'));
      leaderboardSort={key:null,asc:true};
      renderLeaderboard();
    }




	function addPlayer(u,c){
		initGlobal(u);

		// Validate and sanitize color input to prevent XSS
      globalColors[u] = validateColor(c);

		var color = globalColors[u];
		let r, g, b;
		if (color[0] === "#") {
			if (color.length === 4) {
				r = parseInt(color[1] + color[1], 16);
				g = parseInt(color[2] + color[2], 16);
				b = parseInt(color[3] + color[3], 16);
			} else {
				r = parseInt(color.slice(1, 3), 16);
				g = parseInt(color.slice(3, 5), 16);
				b = parseInt(color.slice(5, 7), 16);
			}
		} else if (color.startsWith("rgb")) {
			[r, g, b] = color.match(/\d+/g).map(Number);
		} else {
			[r, g, b] = getComputedStyle(el).color.match(/\d+/g).map(Number);
		}
		const brightness = r * 0.299 + g * 0.587 + b * 0.114;

		if (brightness < 60) {
			// make color 50% brighter
			r = Math.min(255, Math.floor(r * 1.5));
			g = Math.min(255, Math.floor(g * 1.5));
			b = Math.min(255, Math.floor(b * 1.5));
			globalColors[u] = `rgb(${r}, ${g}, ${b})`;
			c = globalColors[u];
		}


		saveGlobalColors();
		const cont=document.createElement('div');
		cont.className='player';
		cont.dataset.username=u;
		const btn=document.createElement('button');
		btn.className='removeBtn';
		btn.textContent='×';
		btn.addEventListener('click',()=>{
			players.delete(u);
			cont.remove();
			btnStart.disabled = players.size===0;
		});
		const img=document.createElement('img');
		img.src='https://static-cdn.jtvnw.net/jtv_user_pictures/xarth/default-user-profile_image-70x70.png';
		fetch(`https://decapi.me/twitch/avatar/${u}`,{mode:'cors'})
			.then(r=>r.text()).then(url=>{ if(url.startsWith('http')) img.src=url; });
		const nmC=document.createElement('div');
		nmC.className='tooltip-container name';
		const sp=document.createElement('span');
		sp.textContent=u;
		sp.style.color=c||'#fff';
		const tip=document.createElement('div');
		tip.className='tooltip-box';
		tip.innerText=getUserTooltipText(u,0,0);
		nmC.append(sp,tip);
		cont.append(btn,img,nmC);
		playersGrid.appendChild(cont);
	}

	function addFakePlayer(u,c){
		initGlobal(u);
		// Validate and sanitize color input to prevent XSS
      globalColors[u] = validateColor(c);

		var color = globalColors[u];
		let r, g, b;
		if (color[0] === "#") {
			if (color.length === 4) {
				r = parseInt(color[1] + color[1], 16);
				g = parseInt(color[2] + color[2], 16);
				b = parseInt(color[3] + color[3], 16);
			} else {
				r = parseInt(color.slice(1, 3), 16);
				g = parseInt(color.slice(3, 5), 16);
				b = parseInt(color.slice(5, 7), 16);
			}
		} else if (color.startsWith("rgb")) {
			[r, g, b] = color.match(/\d+/g).map(Number);
		} else {
			[r, g, b] = getComputedStyle(el).color.match(/\d+/g).map(Number);
		}
		const brightness = r * 0.299 + g * 0.587 + b * 0.114;

		if (brightness < 60) {
			// make color 50% brighter
			r = Math.min(255, Math.floor(r * 1.5));
			g = Math.min(255, Math.floor(g * 1.5));
			b = Math.min(255, Math.floor(b * 1.5));
			globalColors[u] = `rgb(${r}, ${g}, ${b})`;
			c = globalColors[u];
		}

		saveGlobalColors();
		const cont=document.createElement('div');
		cont.className='player';
		cont.dataset.username=u;
		const btn=document.createElement('button');
		btn.className='removeBtn';
		btn.textContent='×';
		btn.addEventListener('click',()=>{
			players.delete(u);
			cont.remove();
			btnStart.disabled = players.size===0;
		});
		const img=document.createElement('img');
		img.src=fakeAvatars[Math.floor(Math.random()*fakeAvatars.length)];
		const nmC=document.createElement('div');
		nmC.className='tooltip-container name';
		const sp=document.createElement('span');
		sp.textContent=u;
		sp.style.color=c||'#fff';
		const tip=document.createElement('div');
		tip.className='tooltip-box';
		tip.innerText=getUserTooltipText(u,0,0);
		nmC.append(sp,tip);
		cont.append(btn,img,nmC);
		playersGrid.appendChild(cont);
	}
  </script>
</body>

</html>
